# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:19:13+00:00

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class ScoreType(Enum):
    SCORE_TYPE_UNSPECIFIED = 'SCORE_TYPE_UNSPECIFIED'
    PROBABILITY = 'PROBABILITY'
    STD_DEV_SCORE = 'STD_DEV_SCORE'
    PERCENTILE = 'PERCENTILE'
    RAW = 'RAW'


class AttributeParameters(BaseModel):
    scoreThreshold: Optional[float] = Field(
        None,
        description="Don't return scores for this attribute that are below this threshold. If unset, a default threshold will be applied. A FloatValue wrapper is used to distinguish between 0 vs. default/unset.",
    )
    scoreType: Optional[ScoreType] = Field(
        None,
        description='What type of scores to return. If unset, defaults to probability scores.',
    )


class Type(Enum):
    SCORE_TYPE_UNSPECIFIED = 'SCORE_TYPE_UNSPECIFIED'
    PROBABILITY = 'PROBABILITY'
    STD_DEV_SCORE = 'STD_DEV_SCORE'
    PERCENTILE = 'PERCENTILE'
    RAW = 'RAW'


class Score(BaseModel):
    type: Optional[Type] = Field(None, description='The type of the above value.')
    value: Optional[float] = Field(
        None, description='Score value. Semantics described by type below.'
    )


class SpanScore(BaseModel):
    begin: Optional[int] = Field(
        None,
        description='"begin" and "end" describe the span of the original text that the attribute score applies to. The values are the UTF-16 codepoint range. "end" is exclusive. For example, with the text "Hi there", the begin/end pair (0,2) describes the text "Hi". If "begin" and "end" are unset, the score applies to the full text.',
    )
    end: Optional[int] = None
    score: Optional[Score] = Field(None, description='The score value.')


class SuggestCommentScoreResponse(BaseModel):
    clientToken: Optional[str] = Field(
        None, description='Same token from the original SuggestCommentScoreRequest.'
    )
    detectedLanguages: Optional[List[str]] = Field(
        None, description='The list of languages detected from the comment text.'
    )
    requestedLanguages: Optional[List[str]] = Field(
        None, description='The list of languages provided in the request.'
    )


class Type1(Enum):
    TEXT_TYPE_UNSPECIFIED = 'TEXT_TYPE_UNSPECIFIED'
    PLAIN_TEXT = 'PLAIN_TEXT'
    HTML = 'HTML'


class TextEntry(BaseModel):
    text: Optional[str] = Field(None, description='UTF-8 encoded text.')
    type: Optional[Type1] = Field(None, description='Type of the text field.')


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class ArticleAndParentComment(BaseModel):
    article: Optional[TextEntry] = Field(
        None,
        description='The source content about which the comment was made (article text, article summary, video transcript, etc).',
    )
    parentComment: Optional[TextEntry] = Field(
        None,
        description='Refers to text that is a direct parent of the source comment, such as in a one-deep threaded message board. This field will only be present for comments that are replies to other comments and will not be populated for direct comments on the article_text.',
    )


class AttributeScores(BaseModel):
    spanScores: Optional[List[SpanScore]] = Field(None, description='Per-span scores.')
    summaryScore: Optional[Score] = Field(
        None, description='Overall score for comment as a whole.'
    )


class Context(BaseModel):
    articleAndParentComment: Optional[ArticleAndParentComment] = Field(
        None,
        description='Information about the source for which the original comment was made, and any parent comment info.',
    )
    entries: Optional[List[TextEntry]] = Field(
        None,
        description='A list of messages. For example, a linear comments section or forum thread.',
    )


class SuggestCommentScoreRequest(BaseModel):
    attributeScores: Optional[Dict[str, AttributeScores]] = Field(
        None,
        description='Attribute scores for the comment. The map keys are attribute names, same as the requested_attribute field in AnalyzeCommentRequest (for example "ATTACK_ON_AUTHOR", "INFLAMMATORY", etc.). This field has the same type as the `attribute_scores` field in AnalyzeCommentResponse. To specify an overall attribute score for the entire comment as a whole, use the `summary_score` field of the mapped AttributeScores object. To specify scores on specific subparts of the comment, use the `span_scores` field. All SpanScore objects must have begin and end fields set. All Score objects must be explicitly set (for binary classification, use the score values 0 and 1). If Score objects don\'t include a ScoreType, `PROBABILITY` is assumed. `attribute_scores` must not be empty. The mapped AttributeScores objects also must not be empty. An `INVALID_ARGUMENT` error is returned for all malformed requests.',
    )
    clientToken: Optional[str] = Field(
        None,
        description='Opaque token that is echoed from the request to the response.',
    )
    comment: Optional[TextEntry] = Field(None, description='The comment being scored.')
    communityId: Optional[str] = Field(
        None,
        description='Optional identifier associating this comment score suggestion with a particular sub-community. Different communities may have different norms and rules. Specifying this value enables training community-specific models.',
    )
    context: Optional[Context] = Field(None, description='The context of the comment.')
    languages: Optional[List[str]] = Field(
        None,
        description='The language(s) of the comment and context. If none are specified, we attempt to automatically detect the language. Both ISO and BCP-47 language codes are accepted.',
    )
    sessionId: Optional[str] = Field(
        None,
        description='Session ID. Used to join related RPCs into a single session. For example, an interactive tool that calls both the AnalyzeComment and SuggestCommentScore RPCs should set all invocations of both RPCs to the same Session ID, typically a random 64-bit integer.',
    )


class AnalyzeCommentRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Opaque token that is echoed from the request to the response.',
    )
    comment: Optional[TextEntry] = Field(None, description='The comment to analyze.')
    communityId: Optional[str] = Field(
        None,
        description="Optional identifier associating this AnalyzeCommentRequest with a particular client's community. Different communities may have different norms and rules. Specifying this value enables us to explore building community-specific models for clients.",
    )
    context: Optional[Context] = Field(None, description='The context of the comment.')
    doNotStore: Optional[bool] = Field(
        None,
        description='Do not store the comment or context sent in this request. By default, the service may store comments/context for debugging purposes.',
    )
    dropUnsupportedAttributes: Optional[bool] = Field(
        None,
        description='If specified, any requested attribute that is requested but not supported for the language detected will be dropped from the returned scores instead of returning an error.',
    )
    languages: Optional[List[str]] = Field(
        None,
        description='The language(s) of the comment and context. If none are specified, we attempt to automatically detect the language. Specifying multiple languages means the text contains multiple lanugages. Both ISO and BCP-47 language codes are accepted. The server returns an error if no language was specified and language detection fails. The server also returns an error if the languages (either specified by the caller, or auto-detected) are not *all* supported by the service.',
    )
    requestedAttributes: Optional[Dict[str, AttributeParameters]] = Field(
        None,
        description='Specification of requested attributes. The AttributeParameters serve as configuration for each associated attribute. The map keys are attribute names. The available attributes may be different on each RFE installation, and can be seen by calling ListAttributes (see above). For the prod installation, known as Perspective API, see https://developers.perspectiveapi.com/s/about-the-api-model-cards.',
    )
    sessionId: Optional[str] = Field(
        None,
        description='Session ID. Used to join related RPCs into a single session. For example, an interactive tool that calls both the AnalyzeComment and SuggestCommentScore RPCs should set all invocations of both RPCs to the same Session ID, typically a random 64-bit integer.',
    )
    spanAnnotations: Optional[bool] = Field(
        None,
        description='An advisory parameter that will return span annotations if the model is capable of providing scores with sub-comment resolution. This will likely increase the size of the returned message.',
    )


class AnalyzeCommentResponse(BaseModel):
    attributeScores: Optional[Dict[str, AttributeScores]] = Field(
        None,
        description='Scores for the requested attributes. The map keys are attribute names (same as the requested_attribute field in AnalyzeCommentRequest, for example "ATTACK_ON_AUTHOR", "INFLAMMATORY", etc).',
    )
    clientToken: Optional[str] = Field(
        None, description='Same token from the original AnalyzeCommentRequest.'
    )
    detectedLanguages: Optional[List[str]] = Field(
        None,
        description='Contains the languages detected from the text content, sorted in order of likelihood.',
    )
    languages: Optional[List[str]] = Field(
        None,
        description='The language(s) used by CommentAnalyzer service to choose which Model to use when analyzing the comment. Might better be called "effective_languages". The logic used to make the choice is as follows: if !Request.languages.empty() effective_languages = Request.languages else effective_languages = detected_languages[0]',
    )
